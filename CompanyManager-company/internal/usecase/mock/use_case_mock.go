package mock

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i github.com/MatthewZholud/CompanyManager-full/CompanyManager-company/internal/usecase.UseCase -o ./use_case_mock_test.go

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// UseCaseMock implements UseCase
type UseCaseMock struct {
	t minimock.Tester

	funcCreateCompany          func(message []byte) (ba1 []byte, err error)
	inspectFuncCreateCompany   func(message []byte)
	afterCreateCompanyCounter  uint64
	beforeCreateCompanyCounter uint64
	CreateCompanyMock          mUseCaseMockCreateCompany

	funcDeleteCompany          func(message []byte) (ba1 []byte, err error)
	inspectFuncDeleteCompany   func(message []byte)
	afterDeleteCompanyCounter  uint64
	beforeDeleteCompanyCounter uint64
	DeleteCompanyMock          mUseCaseMockDeleteCompany

	funcGetCompany          func(message []byte) (ba1 []byte, err error)
	inspectFuncGetCompany   func(message []byte)
	afterGetCompanyCounter  uint64
	beforeGetCompanyCounter uint64
	GetCompanyMock          mUseCaseMockGetCompany

	funcUpdateCompany          func(message []byte) (ba1 []byte, err error)
	inspectFuncUpdateCompany   func(message []byte)
	afterUpdateCompanyCounter  uint64
	beforeUpdateCompanyCounter uint64
	UpdateCompanyMock          mUseCaseMockUpdateCompany
}

// NewUseCaseMock returns a mock for UseCase
func NewUseCaseMock(t minimock.Tester) *UseCaseMock {
	m := &UseCaseMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateCompanyMock = mUseCaseMockCreateCompany{mock: m}
	m.CreateCompanyMock.callArgs = []*UseCaseMockCreateCompanyParams{}

	m.DeleteCompanyMock = mUseCaseMockDeleteCompany{mock: m}
	m.DeleteCompanyMock.callArgs = []*UseCaseMockDeleteCompanyParams{}

	m.GetCompanyMock = mUseCaseMockGetCompany{mock: m}
	m.GetCompanyMock.callArgs = []*UseCaseMockGetCompanyParams{}

	m.UpdateCompanyMock = mUseCaseMockUpdateCompany{mock: m}
	m.UpdateCompanyMock.callArgs = []*UseCaseMockUpdateCompanyParams{}

	return m
}

type mUseCaseMockCreateCompany struct {
	mock               *UseCaseMock
	defaultExpectation *UseCaseMockCreateCompanyExpectation
	expectations       []*UseCaseMockCreateCompanyExpectation

	callArgs []*UseCaseMockCreateCompanyParams
	mutex    sync.RWMutex
}

// UseCaseMockCreateCompanyExpectation specifies expectation struct of the UseCase.CreateCompany
type UseCaseMockCreateCompanyExpectation struct {
	mock    *UseCaseMock
	params  *UseCaseMockCreateCompanyParams
	results *UseCaseMockCreateCompanyResults
	Counter uint64
}

// UseCaseMockCreateCompanyParams contains parameters of the UseCase.CreateCompany
type UseCaseMockCreateCompanyParams struct {
	message []byte
}

// UseCaseMockCreateCompanyResults contains results of the UseCase.CreateCompany
type UseCaseMockCreateCompanyResults struct {
	ba1 []byte
	err error
}

// Expect sets up expected params for UseCase.CreateCompany
func (mmCreateCompany *mUseCaseMockCreateCompany) Expect(message []byte) *mUseCaseMockCreateCompany {
	if mmCreateCompany.mock.funcCreateCompany != nil {
		mmCreateCompany.mock.t.Fatalf("UseCaseMock.CreateCompany mock is already set by Set")
	}

	if mmCreateCompany.defaultExpectation == nil {
		mmCreateCompany.defaultExpectation = &UseCaseMockCreateCompanyExpectation{}
	}

	mmCreateCompany.defaultExpectation.params = &UseCaseMockCreateCompanyParams{message}
	for _, e := range mmCreateCompany.expectations {
		if minimock.Equal(e.params, mmCreateCompany.defaultExpectation.params) {
			mmCreateCompany.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateCompany.defaultExpectation.params)
		}
	}

	return mmCreateCompany
}

// Inspect accepts an inspector function that has same arguments as the UseCase.CreateCompany
func (mmCreateCompany *mUseCaseMockCreateCompany) Inspect(f func(message []byte)) *mUseCaseMockCreateCompany {
	if mmCreateCompany.mock.inspectFuncCreateCompany != nil {
		mmCreateCompany.mock.t.Fatalf("Inspect function is already set for UseCaseMock.CreateCompany")
	}

	mmCreateCompany.mock.inspectFuncCreateCompany = f

	return mmCreateCompany
}

// Return sets up results that will be returned by UseCase.CreateCompany
func (mmCreateCompany *mUseCaseMockCreateCompany) Return(ba1 []byte, err error) *UseCaseMock {
	if mmCreateCompany.mock.funcCreateCompany != nil {
		mmCreateCompany.mock.t.Fatalf("UseCaseMock.CreateCompany mock is already set by Set")
	}

	if mmCreateCompany.defaultExpectation == nil {
		mmCreateCompany.defaultExpectation = &UseCaseMockCreateCompanyExpectation{mock: mmCreateCompany.mock}
	}
	mmCreateCompany.defaultExpectation.results = &UseCaseMockCreateCompanyResults{ba1, err}
	return mmCreateCompany.mock
}

//Set uses given function f to mock the UseCase.CreateCompany method
func (mmCreateCompany *mUseCaseMockCreateCompany) Set(f func(message []byte) (ba1 []byte, err error)) *UseCaseMock {
	if mmCreateCompany.defaultExpectation != nil {
		mmCreateCompany.mock.t.Fatalf("Default expectation is already set for the UseCase.CreateCompany method")
	}

	if len(mmCreateCompany.expectations) > 0 {
		mmCreateCompany.mock.t.Fatalf("Some expectations are already set for the UseCase.CreateCompany method")
	}

	mmCreateCompany.mock.funcCreateCompany = f
	return mmCreateCompany.mock
}

// When sets expectation for the UseCase.CreateCompany which will trigger the result defined by the following
// Then helper
func (mmCreateCompany *mUseCaseMockCreateCompany) When(message []byte) *UseCaseMockCreateCompanyExpectation {
	if mmCreateCompany.mock.funcCreateCompany != nil {
		mmCreateCompany.mock.t.Fatalf("UseCaseMock.CreateCompany mock is already set by Set")
	}

	expectation := &UseCaseMockCreateCompanyExpectation{
		mock:   mmCreateCompany.mock,
		params: &UseCaseMockCreateCompanyParams{message},
	}
	mmCreateCompany.expectations = append(mmCreateCompany.expectations, expectation)
	return expectation
}

// Then sets up UseCase.CreateCompany return parameters for the expectation previously defined by the When method
func (e *UseCaseMockCreateCompanyExpectation) Then(ba1 []byte, err error) *UseCaseMock {
	e.results = &UseCaseMockCreateCompanyResults{ba1, err}
	return e.mock
}

// CreateCompany implements UseCase
func (mmCreateCompany *UseCaseMock) CreateCompany(message []byte) (ba1 []byte, err error) {
	mm_atomic.AddUint64(&mmCreateCompany.beforeCreateCompanyCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateCompany.afterCreateCompanyCounter, 1)

	if mmCreateCompany.inspectFuncCreateCompany != nil {
		mmCreateCompany.inspectFuncCreateCompany(message)
	}

	mm_params := &UseCaseMockCreateCompanyParams{message}

	// Record call args
	mmCreateCompany.CreateCompanyMock.mutex.Lock()
	mmCreateCompany.CreateCompanyMock.callArgs = append(mmCreateCompany.CreateCompanyMock.callArgs, mm_params)
	mmCreateCompany.CreateCompanyMock.mutex.Unlock()

	for _, e := range mmCreateCompany.CreateCompanyMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ba1, e.results.err
		}
	}

	if mmCreateCompany.CreateCompanyMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateCompany.CreateCompanyMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateCompany.CreateCompanyMock.defaultExpectation.params
		mm_got := UseCaseMockCreateCompanyParams{message}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateCompany.t.Errorf("UseCaseMock.CreateCompany got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateCompany.CreateCompanyMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateCompany.t.Fatal("No results are set for the UseCaseMock.CreateCompany")
		}
		return (*mm_results).ba1, (*mm_results).err
	}
	if mmCreateCompany.funcCreateCompany != nil {
		return mmCreateCompany.funcCreateCompany(message)
	}
	mmCreateCompany.t.Fatalf("Unexpected call to UseCaseMock.CreateCompany. %v", message)
	return
}

// CreateCompanyAfterCounter returns a count of finished UseCaseMock.CreateCompany invocations
func (mmCreateCompany *UseCaseMock) CreateCompanyAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateCompany.afterCreateCompanyCounter)
}

// CreateCompanyBeforeCounter returns a count of UseCaseMock.CreateCompany invocations
func (mmCreateCompany *UseCaseMock) CreateCompanyBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateCompany.beforeCreateCompanyCounter)
}

// Calls returns a list of arguments used in each call to UseCaseMock.CreateCompany.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateCompany *mUseCaseMockCreateCompany) Calls() []*UseCaseMockCreateCompanyParams {
	mmCreateCompany.mutex.RLock()

	argCopy := make([]*UseCaseMockCreateCompanyParams, len(mmCreateCompany.callArgs))
	copy(argCopy, mmCreateCompany.callArgs)

	mmCreateCompany.mutex.RUnlock()

	return argCopy
}

// MinimockCreateCompanyDone returns true if the count of the CreateCompany invocations corresponds
// the number of defined expectations
func (m *UseCaseMock) MinimockCreateCompanyDone() bool {
	for _, e := range m.CreateCompanyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateCompanyMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateCompanyCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateCompany != nil && mm_atomic.LoadUint64(&m.afterCreateCompanyCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateCompanyInspect logs each unmet expectation
func (m *UseCaseMock) MinimockCreateCompanyInspect() {
	for _, e := range m.CreateCompanyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UseCaseMock.CreateCompany with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateCompanyMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateCompanyCounter) < 1 {
		if m.CreateCompanyMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UseCaseMock.CreateCompany")
		} else {
			m.t.Errorf("Expected call to UseCaseMock.CreateCompany with params: %#v", *m.CreateCompanyMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateCompany != nil && mm_atomic.LoadUint64(&m.afterCreateCompanyCounter) < 1 {
		m.t.Error("Expected call to UseCaseMock.CreateCompany")
	}
}

type mUseCaseMockDeleteCompany struct {
	mock               *UseCaseMock
	defaultExpectation *UseCaseMockDeleteCompanyExpectation
	expectations       []*UseCaseMockDeleteCompanyExpectation

	callArgs []*UseCaseMockDeleteCompanyParams
	mutex    sync.RWMutex
}

// UseCaseMockDeleteCompanyExpectation specifies expectation struct of the UseCase.DeleteCompany
type UseCaseMockDeleteCompanyExpectation struct {
	mock    *UseCaseMock
	params  *UseCaseMockDeleteCompanyParams
	results *UseCaseMockDeleteCompanyResults
	Counter uint64
}

// UseCaseMockDeleteCompanyParams contains parameters of the UseCase.DeleteCompany
type UseCaseMockDeleteCompanyParams struct {
	message []byte
}

// UseCaseMockDeleteCompanyResults contains results of the UseCase.DeleteCompany
type UseCaseMockDeleteCompanyResults struct {
	ba1 []byte
	err error
}

// Expect sets up expected params for UseCase.DeleteCompany
func (mmDeleteCompany *mUseCaseMockDeleteCompany) Expect(message []byte) *mUseCaseMockDeleteCompany {
	if mmDeleteCompany.mock.funcDeleteCompany != nil {
		mmDeleteCompany.mock.t.Fatalf("UseCaseMock.DeleteCompany mock is already set by Set")
	}

	if mmDeleteCompany.defaultExpectation == nil {
		mmDeleteCompany.defaultExpectation = &UseCaseMockDeleteCompanyExpectation{}
	}

	mmDeleteCompany.defaultExpectation.params = &UseCaseMockDeleteCompanyParams{message}
	for _, e := range mmDeleteCompany.expectations {
		if minimock.Equal(e.params, mmDeleteCompany.defaultExpectation.params) {
			mmDeleteCompany.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteCompany.defaultExpectation.params)
		}
	}

	return mmDeleteCompany
}

// Inspect accepts an inspector function that has same arguments as the UseCase.DeleteCompany
func (mmDeleteCompany *mUseCaseMockDeleteCompany) Inspect(f func(message []byte)) *mUseCaseMockDeleteCompany {
	if mmDeleteCompany.mock.inspectFuncDeleteCompany != nil {
		mmDeleteCompany.mock.t.Fatalf("Inspect function is already set for UseCaseMock.DeleteCompany")
	}

	mmDeleteCompany.mock.inspectFuncDeleteCompany = f

	return mmDeleteCompany
}

// Return sets up results that will be returned by UseCase.DeleteCompany
func (mmDeleteCompany *mUseCaseMockDeleteCompany) Return(ba1 []byte, err error) *UseCaseMock {
	if mmDeleteCompany.mock.funcDeleteCompany != nil {
		mmDeleteCompany.mock.t.Fatalf("UseCaseMock.DeleteCompany mock is already set by Set")
	}

	if mmDeleteCompany.defaultExpectation == nil {
		mmDeleteCompany.defaultExpectation = &UseCaseMockDeleteCompanyExpectation{mock: mmDeleteCompany.mock}
	}
	mmDeleteCompany.defaultExpectation.results = &UseCaseMockDeleteCompanyResults{ba1, err}
	return mmDeleteCompany.mock
}

//Set uses given function f to mock the UseCase.DeleteCompany method
func (mmDeleteCompany *mUseCaseMockDeleteCompany) Set(f func(message []byte) (ba1 []byte, err error)) *UseCaseMock {
	if mmDeleteCompany.defaultExpectation != nil {
		mmDeleteCompany.mock.t.Fatalf("Default expectation is already set for the UseCase.DeleteCompany method")
	}

	if len(mmDeleteCompany.expectations) > 0 {
		mmDeleteCompany.mock.t.Fatalf("Some expectations are already set for the UseCase.DeleteCompany method")
	}

	mmDeleteCompany.mock.funcDeleteCompany = f
	return mmDeleteCompany.mock
}

// When sets expectation for the UseCase.DeleteCompany which will trigger the result defined by the following
// Then helper
func (mmDeleteCompany *mUseCaseMockDeleteCompany) When(message []byte) *UseCaseMockDeleteCompanyExpectation {
	if mmDeleteCompany.mock.funcDeleteCompany != nil {
		mmDeleteCompany.mock.t.Fatalf("UseCaseMock.DeleteCompany mock is already set by Set")
	}

	expectation := &UseCaseMockDeleteCompanyExpectation{
		mock:   mmDeleteCompany.mock,
		params: &UseCaseMockDeleteCompanyParams{message},
	}
	mmDeleteCompany.expectations = append(mmDeleteCompany.expectations, expectation)
	return expectation
}

// Then sets up UseCase.DeleteCompany return parameters for the expectation previously defined by the When method
func (e *UseCaseMockDeleteCompanyExpectation) Then(ba1 []byte, err error) *UseCaseMock {
	e.results = &UseCaseMockDeleteCompanyResults{ba1, err}
	return e.mock
}

// DeleteCompany implements UseCase
func (mmDeleteCompany *UseCaseMock) DeleteCompany(message []byte) (ba1 []byte, err error) {
	mm_atomic.AddUint64(&mmDeleteCompany.beforeDeleteCompanyCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteCompany.afterDeleteCompanyCounter, 1)

	if mmDeleteCompany.inspectFuncDeleteCompany != nil {
		mmDeleteCompany.inspectFuncDeleteCompany(message)
	}

	mm_params := &UseCaseMockDeleteCompanyParams{message}

	// Record call args
	mmDeleteCompany.DeleteCompanyMock.mutex.Lock()
	mmDeleteCompany.DeleteCompanyMock.callArgs = append(mmDeleteCompany.DeleteCompanyMock.callArgs, mm_params)
	mmDeleteCompany.DeleteCompanyMock.mutex.Unlock()

	for _, e := range mmDeleteCompany.DeleteCompanyMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ba1, e.results.err
		}
	}

	if mmDeleteCompany.DeleteCompanyMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteCompany.DeleteCompanyMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteCompany.DeleteCompanyMock.defaultExpectation.params
		mm_got := UseCaseMockDeleteCompanyParams{message}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteCompany.t.Errorf("UseCaseMock.DeleteCompany got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteCompany.DeleteCompanyMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteCompany.t.Fatal("No results are set for the UseCaseMock.DeleteCompany")
		}
		return (*mm_results).ba1, (*mm_results).err
	}
	if mmDeleteCompany.funcDeleteCompany != nil {
		return mmDeleteCompany.funcDeleteCompany(message)
	}
	mmDeleteCompany.t.Fatalf("Unexpected call to UseCaseMock.DeleteCompany. %v", message)
	return
}

// DeleteCompanyAfterCounter returns a count of finished UseCaseMock.DeleteCompany invocations
func (mmDeleteCompany *UseCaseMock) DeleteCompanyAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteCompany.afterDeleteCompanyCounter)
}

// DeleteCompanyBeforeCounter returns a count of UseCaseMock.DeleteCompany invocations
func (mmDeleteCompany *UseCaseMock) DeleteCompanyBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteCompany.beforeDeleteCompanyCounter)
}

// Calls returns a list of arguments used in each call to UseCaseMock.DeleteCompany.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteCompany *mUseCaseMockDeleteCompany) Calls() []*UseCaseMockDeleteCompanyParams {
	mmDeleteCompany.mutex.RLock()

	argCopy := make([]*UseCaseMockDeleteCompanyParams, len(mmDeleteCompany.callArgs))
	copy(argCopy, mmDeleteCompany.callArgs)

	mmDeleteCompany.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteCompanyDone returns true if the count of the DeleteCompany invocations corresponds
// the number of defined expectations
func (m *UseCaseMock) MinimockDeleteCompanyDone() bool {
	for _, e := range m.DeleteCompanyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteCompanyMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteCompanyCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteCompany != nil && mm_atomic.LoadUint64(&m.afterDeleteCompanyCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteCompanyInspect logs each unmet expectation
func (m *UseCaseMock) MinimockDeleteCompanyInspect() {
	for _, e := range m.DeleteCompanyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UseCaseMock.DeleteCompany with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteCompanyMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteCompanyCounter) < 1 {
		if m.DeleteCompanyMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UseCaseMock.DeleteCompany")
		} else {
			m.t.Errorf("Expected call to UseCaseMock.DeleteCompany with params: %#v", *m.DeleteCompanyMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteCompany != nil && mm_atomic.LoadUint64(&m.afterDeleteCompanyCounter) < 1 {
		m.t.Error("Expected call to UseCaseMock.DeleteCompany")
	}
}

type mUseCaseMockGetCompany struct {
	mock               *UseCaseMock
	defaultExpectation *UseCaseMockGetCompanyExpectation
	expectations       []*UseCaseMockGetCompanyExpectation

	callArgs []*UseCaseMockGetCompanyParams
	mutex    sync.RWMutex
}

// UseCaseMockGetCompanyExpectation specifies expectation struct of the UseCase.GetCompany
type UseCaseMockGetCompanyExpectation struct {
	mock    *UseCaseMock
	params  *UseCaseMockGetCompanyParams
	results *UseCaseMockGetCompanyResults
	Counter uint64
}

// UseCaseMockGetCompanyParams contains parameters of the UseCase.GetCompany
type UseCaseMockGetCompanyParams struct {
	message []byte
}

// UseCaseMockGetCompanyResults contains results of the UseCase.GetCompany
type UseCaseMockGetCompanyResults struct {
	ba1 []byte
	err error
}

// Expect sets up expected params for UseCase.GetCompany
func (mmGetCompany *mUseCaseMockGetCompany) Expect(message []byte) *mUseCaseMockGetCompany {
	if mmGetCompany.mock.funcGetCompany != nil {
		mmGetCompany.mock.t.Fatalf("UseCaseMock.GetCompany mock is already set by Set")
	}

	if mmGetCompany.defaultExpectation == nil {
		mmGetCompany.defaultExpectation = &UseCaseMockGetCompanyExpectation{}
	}

	mmGetCompany.defaultExpectation.params = &UseCaseMockGetCompanyParams{message}
	for _, e := range mmGetCompany.expectations {
		if minimock.Equal(e.params, mmGetCompany.defaultExpectation.params) {
			mmGetCompany.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetCompany.defaultExpectation.params)
		}
	}

	return mmGetCompany
}

// Inspect accepts an inspector function that has same arguments as the UseCase.GetCompany
func (mmGetCompany *mUseCaseMockGetCompany) Inspect(f func(message []byte)) *mUseCaseMockGetCompany {
	if mmGetCompany.mock.inspectFuncGetCompany != nil {
		mmGetCompany.mock.t.Fatalf("Inspect function is already set for UseCaseMock.GetCompany")
	}

	mmGetCompany.mock.inspectFuncGetCompany = f

	return mmGetCompany
}

// Return sets up results that will be returned by UseCase.GetCompany
func (mmGetCompany *mUseCaseMockGetCompany) Return(ba1 []byte, err error) *UseCaseMock {
	if mmGetCompany.mock.funcGetCompany != nil {
		mmGetCompany.mock.t.Fatalf("UseCaseMock.GetCompany mock is already set by Set")
	}

	if mmGetCompany.defaultExpectation == nil {
		mmGetCompany.defaultExpectation = &UseCaseMockGetCompanyExpectation{mock: mmGetCompany.mock}
	}
	mmGetCompany.defaultExpectation.results = &UseCaseMockGetCompanyResults{ba1, err}
	return mmGetCompany.mock
}

//Set uses given function f to mock the UseCase.GetCompany method
func (mmGetCompany *mUseCaseMockGetCompany) Set(f func(message []byte) (ba1 []byte, err error)) *UseCaseMock {
	if mmGetCompany.defaultExpectation != nil {
		mmGetCompany.mock.t.Fatalf("Default expectation is already set for the UseCase.GetCompany method")
	}

	if len(mmGetCompany.expectations) > 0 {
		mmGetCompany.mock.t.Fatalf("Some expectations are already set for the UseCase.GetCompany method")
	}

	mmGetCompany.mock.funcGetCompany = f
	return mmGetCompany.mock
}

// When sets expectation for the UseCase.GetCompany which will trigger the result defined by the following
// Then helper
func (mmGetCompany *mUseCaseMockGetCompany) When(message []byte) *UseCaseMockGetCompanyExpectation {
	if mmGetCompany.mock.funcGetCompany != nil {
		mmGetCompany.mock.t.Fatalf("UseCaseMock.GetCompany mock is already set by Set")
	}

	expectation := &UseCaseMockGetCompanyExpectation{
		mock:   mmGetCompany.mock,
		params: &UseCaseMockGetCompanyParams{message},
	}
	mmGetCompany.expectations = append(mmGetCompany.expectations, expectation)
	return expectation
}

// Then sets up UseCase.GetCompany return parameters for the expectation previously defined by the When method
func (e *UseCaseMockGetCompanyExpectation) Then(ba1 []byte, err error) *UseCaseMock {
	e.results = &UseCaseMockGetCompanyResults{ba1, err}
	return e.mock
}

// GetCompany implements UseCase
func (mmGetCompany *UseCaseMock) GetCompany(message []byte) (ba1 []byte, err error) {
	mm_atomic.AddUint64(&mmGetCompany.beforeGetCompanyCounter, 1)
	defer mm_atomic.AddUint64(&mmGetCompany.afterGetCompanyCounter, 1)

	if mmGetCompany.inspectFuncGetCompany != nil {
		mmGetCompany.inspectFuncGetCompany(message)
	}

	mm_params := &UseCaseMockGetCompanyParams{message}

	// Record call args
	mmGetCompany.GetCompanyMock.mutex.Lock()
	mmGetCompany.GetCompanyMock.callArgs = append(mmGetCompany.GetCompanyMock.callArgs, mm_params)
	mmGetCompany.GetCompanyMock.mutex.Unlock()

	for _, e := range mmGetCompany.GetCompanyMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ba1, e.results.err
		}
	}

	if mmGetCompany.GetCompanyMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetCompany.GetCompanyMock.defaultExpectation.Counter, 1)
		mm_want := mmGetCompany.GetCompanyMock.defaultExpectation.params
		mm_got := UseCaseMockGetCompanyParams{message}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetCompany.t.Errorf("UseCaseMock.GetCompany got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetCompany.GetCompanyMock.defaultExpectation.results
		if mm_results == nil {
			mmGetCompany.t.Fatal("No results are set for the UseCaseMock.GetCompany")
		}
		return (*mm_results).ba1, (*mm_results).err
	}
	if mmGetCompany.funcGetCompany != nil {
		return mmGetCompany.funcGetCompany(message)
	}
	mmGetCompany.t.Fatalf("Unexpected call to UseCaseMock.GetCompany. %v", message)
	return
}

// GetCompanyAfterCounter returns a count of finished UseCaseMock.GetCompany invocations
func (mmGetCompany *UseCaseMock) GetCompanyAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCompany.afterGetCompanyCounter)
}

// GetCompanyBeforeCounter returns a count of UseCaseMock.GetCompany invocations
func (mmGetCompany *UseCaseMock) GetCompanyBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCompany.beforeGetCompanyCounter)
}

// Calls returns a list of arguments used in each call to UseCaseMock.GetCompany.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetCompany *mUseCaseMockGetCompany) Calls() []*UseCaseMockGetCompanyParams {
	mmGetCompany.mutex.RLock()

	argCopy := make([]*UseCaseMockGetCompanyParams, len(mmGetCompany.callArgs))
	copy(argCopy, mmGetCompany.callArgs)

	mmGetCompany.mutex.RUnlock()

	return argCopy
}

// MinimockGetCompanyDone returns true if the count of the GetCompany invocations corresponds
// the number of defined expectations
func (m *UseCaseMock) MinimockGetCompanyDone() bool {
	for _, e := range m.GetCompanyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetCompanyMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCompanyCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCompany != nil && mm_atomic.LoadUint64(&m.afterGetCompanyCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetCompanyInspect logs each unmet expectation
func (m *UseCaseMock) MinimockGetCompanyInspect() {
	for _, e := range m.GetCompanyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UseCaseMock.GetCompany with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetCompanyMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCompanyCounter) < 1 {
		if m.GetCompanyMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UseCaseMock.GetCompany")
		} else {
			m.t.Errorf("Expected call to UseCaseMock.GetCompany with params: %#v", *m.GetCompanyMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCompany != nil && mm_atomic.LoadUint64(&m.afterGetCompanyCounter) < 1 {
		m.t.Error("Expected call to UseCaseMock.GetCompany")
	}
}

type mUseCaseMockUpdateCompany struct {
	mock               *UseCaseMock
	defaultExpectation *UseCaseMockUpdateCompanyExpectation
	expectations       []*UseCaseMockUpdateCompanyExpectation

	callArgs []*UseCaseMockUpdateCompanyParams
	mutex    sync.RWMutex
}

// UseCaseMockUpdateCompanyExpectation specifies expectation struct of the UseCase.UpdateCompany
type UseCaseMockUpdateCompanyExpectation struct {
	mock    *UseCaseMock
	params  *UseCaseMockUpdateCompanyParams
	results *UseCaseMockUpdateCompanyResults
	Counter uint64
}

// UseCaseMockUpdateCompanyParams contains parameters of the UseCase.UpdateCompany
type UseCaseMockUpdateCompanyParams struct {
	message []byte
}

// UseCaseMockUpdateCompanyResults contains results of the UseCase.UpdateCompany
type UseCaseMockUpdateCompanyResults struct {
	ba1 []byte
	err error
}

// Expect sets up expected params for UseCase.UpdateCompany
func (mmUpdateCompany *mUseCaseMockUpdateCompany) Expect(message []byte) *mUseCaseMockUpdateCompany {
	if mmUpdateCompany.mock.funcUpdateCompany != nil {
		mmUpdateCompany.mock.t.Fatalf("UseCaseMock.UpdateCompany mock is already set by Set")
	}

	if mmUpdateCompany.defaultExpectation == nil {
		mmUpdateCompany.defaultExpectation = &UseCaseMockUpdateCompanyExpectation{}
	}

	mmUpdateCompany.defaultExpectation.params = &UseCaseMockUpdateCompanyParams{message}
	for _, e := range mmUpdateCompany.expectations {
		if minimock.Equal(e.params, mmUpdateCompany.defaultExpectation.params) {
			mmUpdateCompany.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateCompany.defaultExpectation.params)
		}
	}

	return mmUpdateCompany
}

// Inspect accepts an inspector function that has same arguments as the UseCase.UpdateCompany
func (mmUpdateCompany *mUseCaseMockUpdateCompany) Inspect(f func(message []byte)) *mUseCaseMockUpdateCompany {
	if mmUpdateCompany.mock.inspectFuncUpdateCompany != nil {
		mmUpdateCompany.mock.t.Fatalf("Inspect function is already set for UseCaseMock.UpdateCompany")
	}

	mmUpdateCompany.mock.inspectFuncUpdateCompany = f

	return mmUpdateCompany
}

// Return sets up results that will be returned by UseCase.UpdateCompany
func (mmUpdateCompany *mUseCaseMockUpdateCompany) Return(ba1 []byte, err error) *UseCaseMock {
	if mmUpdateCompany.mock.funcUpdateCompany != nil {
		mmUpdateCompany.mock.t.Fatalf("UseCaseMock.UpdateCompany mock is already set by Set")
	}

	if mmUpdateCompany.defaultExpectation == nil {
		mmUpdateCompany.defaultExpectation = &UseCaseMockUpdateCompanyExpectation{mock: mmUpdateCompany.mock}
	}
	mmUpdateCompany.defaultExpectation.results = &UseCaseMockUpdateCompanyResults{ba1, err}
	return mmUpdateCompany.mock
}

//Set uses given function f to mock the UseCase.UpdateCompany method
func (mmUpdateCompany *mUseCaseMockUpdateCompany) Set(f func(message []byte) (ba1 []byte, err error)) *UseCaseMock {
	if mmUpdateCompany.defaultExpectation != nil {
		mmUpdateCompany.mock.t.Fatalf("Default expectation is already set for the UseCase.UpdateCompany method")
	}

	if len(mmUpdateCompany.expectations) > 0 {
		mmUpdateCompany.mock.t.Fatalf("Some expectations are already set for the UseCase.UpdateCompany method")
	}

	mmUpdateCompany.mock.funcUpdateCompany = f
	return mmUpdateCompany.mock
}

// When sets expectation for the UseCase.UpdateCompany which will trigger the result defined by the following
// Then helper
func (mmUpdateCompany *mUseCaseMockUpdateCompany) When(message []byte) *UseCaseMockUpdateCompanyExpectation {
	if mmUpdateCompany.mock.funcUpdateCompany != nil {
		mmUpdateCompany.mock.t.Fatalf("UseCaseMock.UpdateCompany mock is already set by Set")
	}

	expectation := &UseCaseMockUpdateCompanyExpectation{
		mock:   mmUpdateCompany.mock,
		params: &UseCaseMockUpdateCompanyParams{message},
	}
	mmUpdateCompany.expectations = append(mmUpdateCompany.expectations, expectation)
	return expectation
}

// Then sets up UseCase.UpdateCompany return parameters for the expectation previously defined by the When method
func (e *UseCaseMockUpdateCompanyExpectation) Then(ba1 []byte, err error) *UseCaseMock {
	e.results = &UseCaseMockUpdateCompanyResults{ba1, err}
	return e.mock
}

// UpdateCompany implements UseCase
func (mmUpdateCompany *UseCaseMock) UpdateCompany(message []byte) (ba1 []byte, err error) {
	mm_atomic.AddUint64(&mmUpdateCompany.beforeUpdateCompanyCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateCompany.afterUpdateCompanyCounter, 1)

	if mmUpdateCompany.inspectFuncUpdateCompany != nil {
		mmUpdateCompany.inspectFuncUpdateCompany(message)
	}

	mm_params := &UseCaseMockUpdateCompanyParams{message}

	// Record call args
	mmUpdateCompany.UpdateCompanyMock.mutex.Lock()
	mmUpdateCompany.UpdateCompanyMock.callArgs = append(mmUpdateCompany.UpdateCompanyMock.callArgs, mm_params)
	mmUpdateCompany.UpdateCompanyMock.mutex.Unlock()

	for _, e := range mmUpdateCompany.UpdateCompanyMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ba1, e.results.err
		}
	}

	if mmUpdateCompany.UpdateCompanyMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateCompany.UpdateCompanyMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateCompany.UpdateCompanyMock.defaultExpectation.params
		mm_got := UseCaseMockUpdateCompanyParams{message}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateCompany.t.Errorf("UseCaseMock.UpdateCompany got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateCompany.UpdateCompanyMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateCompany.t.Fatal("No results are set for the UseCaseMock.UpdateCompany")
		}
		return (*mm_results).ba1, (*mm_results).err
	}
	if mmUpdateCompany.funcUpdateCompany != nil {
		return mmUpdateCompany.funcUpdateCompany(message)
	}
	mmUpdateCompany.t.Fatalf("Unexpected call to UseCaseMock.UpdateCompany. %v", message)
	return
}

// UpdateCompanyAfterCounter returns a count of finished UseCaseMock.UpdateCompany invocations
func (mmUpdateCompany *UseCaseMock) UpdateCompanyAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateCompany.afterUpdateCompanyCounter)
}

// UpdateCompanyBeforeCounter returns a count of UseCaseMock.UpdateCompany invocations
func (mmUpdateCompany *UseCaseMock) UpdateCompanyBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateCompany.beforeUpdateCompanyCounter)
}

// Calls returns a list of arguments used in each call to UseCaseMock.UpdateCompany.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateCompany *mUseCaseMockUpdateCompany) Calls() []*UseCaseMockUpdateCompanyParams {
	mmUpdateCompany.mutex.RLock()

	argCopy := make([]*UseCaseMockUpdateCompanyParams, len(mmUpdateCompany.callArgs))
	copy(argCopy, mmUpdateCompany.callArgs)

	mmUpdateCompany.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateCompanyDone returns true if the count of the UpdateCompany invocations corresponds
// the number of defined expectations
func (m *UseCaseMock) MinimockUpdateCompanyDone() bool {
	for _, e := range m.UpdateCompanyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateCompanyMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateCompanyCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateCompany != nil && mm_atomic.LoadUint64(&m.afterUpdateCompanyCounter) < 1 {
		return false
	}
	return true
}

// MinimockUpdateCompanyInspect logs each unmet expectation
func (m *UseCaseMock) MinimockUpdateCompanyInspect() {
	for _, e := range m.UpdateCompanyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UseCaseMock.UpdateCompany with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateCompanyMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateCompanyCounter) < 1 {
		if m.UpdateCompanyMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UseCaseMock.UpdateCompany")
		} else {
			m.t.Errorf("Expected call to UseCaseMock.UpdateCompany with params: %#v", *m.UpdateCompanyMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateCompany != nil && mm_atomic.LoadUint64(&m.afterUpdateCompanyCounter) < 1 {
		m.t.Error("Expected call to UseCaseMock.UpdateCompany")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *UseCaseMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockCreateCompanyInspect()

		m.MinimockDeleteCompanyInspect()

		m.MinimockGetCompanyInspect()

		m.MinimockUpdateCompanyInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *UseCaseMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *UseCaseMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateCompanyDone() &&
		m.MinimockDeleteCompanyDone() &&
		m.MinimockGetCompanyDone() &&
		m.MinimockUpdateCompanyDone()
}
